* when moving the 'present' pointer backwards and creating a new branch of time there needs to be an overarching sense of 'wallclock' time that orders the branches as the appeared in the timeline, because when calling 'next' on a present node in which moving forward presets an array of possible 'next' states (a forking node) then you must be able to index them in the order that they were created
still need to implement the 'mods' mirrored data structure
is there a way to remove the .toJS() call when checking values
what should length return?
  the length of the last node's value?
  or the length of the temporal collection's timeline?
  this leads to a larger question of should you be allowed to map over a list's entire timeline or reduce (etc)
should we switch to an array implementation of the whole thing so you don't have to iterate to find the last node?
just finish the implementation for add
just finish the fucking list for add and remove don't do anything fancy, 
there're still like 6 more implementations of List to build
how should we be testing the inherent additive node behavior?
should it be in every test or separate tests?
por que no los dos?
working on remove from index
would 2d array storage make more sense than linkedlist?
do shift and unshift still make sense?
